同一个函数的出口只有两个地方： 正常和异常， 任何异常都要用goto fail跳转到fail: ， 防止多处失败忘记执行异常处理，如果一个fail状态不够，可增加为fail1,fail2，但异常状态都必须在函数的最底端实现

不能在程序中频繁调用malloc(), free()这一类的函数， 需空间必须在开始申请，结束释放

最好不要在循环次数较多的代码中加断言语名，如果要调试，都必须用宏，在发布状态下这些宏要置空

打印函数或者任何用来帮助调试的函数都必须用宏来实现，在发布状态下可能会置空

模块最好只有三个API函数， init(), uninit(), process()

任何模块要尽可能少地依赖其它模块或者公用函数，但要尽可能地提供易用易扩展且尽量统一的接口

在程序中要最大可能地避免调用system()函数，除非万不得已

在程序中要尽可能少的引用与平台相关的头文件，如<sys/...>, 否则对平台移植不利

工程中不能直接引用模块， 也不能将所有模块全部放在一起构成一个巨大的公用库， 工程中需什么模块动态地将模块的.c/.h拷贝进来，并说明引用模块的版本号
若模块升级后，再将升级的模块拷贝进来

工程的软件架构要尽量地扁平化，避免层层深入层层调用，且层层接口耦合过紧，可引入抽象层API， 但在抽象层的接口不能与底层API的接口形成包含关系， 尽可能地保成模块的独立性，易插入易提取

在模块中要考虑多线程同时调用一个模块的情况，所以在模块中不要有全局变量，也不要用static， 所有的变量在init时分配一个Context，放在Context中，
这样不同的线程，或者要多模块同时工作时只需要申请不同的Context即可

每个文件和主要函数都在前面加入fa_， 这样可以保证在任何一个其它程序不会与相同作用的函数冲突，例如fft()， 在大部分的代码中都有fft,但我们如命名为
fa_fft()则做到了与其它函数的区分，即使同时存在也不会起任何冲突

结构体定义都用
typedef struct _XXX{
}XXX_t的形式， XXX_t中的t表明为类型定义


文件级的static 函数可以不加fa_前缀，但任何在.h文件中的外部函数都必须加上fa_前缀，一则为了标明是fa源代码，二则避免与其它同类函数的函数名相同而起冲突

函数用init产生handle, uninit释放handle, 定义的上下文在头文件中应该对用户不可见，放到.c文件中

尽量不要把结构体的数据结构放在头文件中，头文件尽量是宏定义和API函数

尽量只关心输入参数和输入结果，而对上下文具体内容不关心




